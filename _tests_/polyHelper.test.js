import * as polyHelper from '../helpers/polyHelper';
import * as testData from '../fake-data/fake-data';

describe('f() difference', () => {
  test('basic cross shape', () => {
    expect(
      polyHelper.difference(testData.cross.vertical, testData.cross.horizontal)
    ).toEqual(testData.cross.difference);
  });

  test('snake & spike', () => {
    expect(
      polyHelper.difference(testData.snake.snake, testData.snake.spike)
    ).toEqual(testData.snake.difference);
  });

  test('island surrounded', () => {
    expect(
      polyHelper.difference(testData.island.inner, testData.island.outer)
    ).toEqual([]);
  });

  test('cut island out of shape', () => {
    expect(
      polyHelper.difference(testData.island.outer, testData.island.inner)
    ).toEqual([testData.island.outer]);
  });

  test('donut shape', () => {
    expect(
      polyHelper.difference(testData.donut.top, testData.donut.bottom)
    ).toEqual(testData.donut.difference);
  });
});

describe('f() sanitizeInversion', () => {
  test('reverses an inverted polygon', () => {
    expect(polyHelper.sanitizeInversion(testData.inverted.inverted)).toEqual(
      testData.inverted.notInverted
    );
  });

  test('does nothing to a non-inverted polygon', () => {
    expect(polyHelper.sanitizeInversion(testData.inverted.notInverted)).toEqual(
      testData.inverted.notInverted
    );
  });

  test('fixes basic inverted square', () => {
    const inverted = [
      [1, 0],
      [0, 0],
      [0, 1],
      [1, 1]
    ];
    expect(polyHelper.sanitizeInversion(inverted)).toEqual([
      [1, 1],
      [0, 1],
      [0, 0],
      [1, 0]
    ]);
  });
});

describe('f() flattenPolygon', () => {
  test('figure8', () => {
    expect(polyHelper.flattenPolygon(testData.selfCrossing.figure8)).toEqual([
      [47.62493839613551, -122.35922399908304],
      [47.623792717162736, -122.35922399908304],
      [47.621262417655934, -122.35890716314317],
      [47.6190239823868, -122.35906608402729],
      [47.62041021901962, -122.35594365745784],
      [47.62198195084879, -122.35293958336115],
      [47.622408308237894, -122.35200570547505],
      [47.623046543509034, -122.35060773789881],
      [47.62461842205012, -122.34732739627363],
      [47.62493839613551, -122.3457458987832],
      [47.622514362878974, -122.3455883190036],
      [47.61998400149665, -122.34542939811946],
      [47.61841198360306, -122.3455883190036],
      [47.622408308237894, -122.35200570547505],
      [47.62358052652604, -122.35388807952404],
      [47.62451244150106, -122.35641773790121],
      [47.62547077805564, -122.35890716314317]
    ]);
  });

  test('simpleStar shape', () => {
    expect(polyHelper.flattenPolygon(testData.selfCrossing.simpleStar)).toEqual(
      [
        [47.63548604966279, -122.36625976860522],
        [47.634473196097055, -122.36483054549288],
        [47.633622036769616, -122.36362948679673],
        [47.631704621063484, -122.36092384904624],
        [47.634123558657556, -122.36057729387629],
        [47.634805660998346, -122.36047957077123],
        [47.636951372875835, -122.3601721599698],
        [47.63516478853261, -122.36353051548],
        [47.634473196097055, -122.36483054549288],
        [47.63295609026599, -122.3676823452115],
        [47.633622036769616, -122.36362948679673],
        [47.634123558657556, -122.36057729387629],
        [47.634527670811245, -122.35811792314054],
        [47.634805660998346, -122.36047957077123],
        [47.63516478853261, -122.36353051548]
      ]
    );
  });

  test('star shape', () => {
    expect(polyHelper.flattenPolygon(testData.selfCrossing.star)).toEqual([
      [47.620196206731656, -122.36467827111484],
      [47.61934399071542, -122.363452501595],
      [47.61798574978985, -122.36250400543213],
      [47.6165233889241, -122.36122913881263],
      [47.616173200284564, -122.36092384904624],
      [47.61313670006637, -122.35716808587313],
      [47.612675166690295, -122.35628691507925],
      [47.61175027058802, -122.35452108085154],
      [47.60964569351914, -122.34997574239968],
      [47.60796712466814, -122.3466943949461],
      [47.61207032343402, -122.34542939811946],
      [47.614301470947645, -122.34504403260058],
      [47.614815103002286, -122.34495531767607],
      [47.61745351764217, -122.34420496970415],
      [47.61886704233114, -122.34413224184358],
      [47.620516207885395, -122.34404738992453],
      [47.62283434984354, -122.3435716331005],
      [47.625044601790215, -122.34309755265713],
      [47.62315433484945, -122.34732739627363],
      [47.62026373185413, -122.35257311820394],
      [47.619451563696735, -122.35404700040817],
      [47.61841198360306, -122.3579590022564],
      [47.617345714547334, -122.3601721599698],
      [47.6165233889241, -122.36122913881263],
      [47.61396257325794, -122.36452069133519],
      [47.61081835414786, -122.36515268683432],
      [47.61196431744703, -122.36044976860283],
      [47.612675166690295, -122.35628691507925],
      [47.61292288402756, -122.35483624041082],
      [47.61313670006637, -122.35171381384136],
      [47.61364253199267, -122.34764289110899],
      [47.614301470947645, -122.34504403260058],
      [47.615987421710436, -122.33839463442564],
      [47.61681347588452, -122.33701128512621],
      [47.618305764473085, -122.34167497605087],
      [47.61886704233114, -122.34413224184358],
      [47.61934399071542, -122.34622031450273],
      [47.62026373185413, -122.35257311820394],
      [47.62081112246857, -122.3563540354371],
      [47.62091869243119, -122.36121587455274],
      [47.621344902334194, -122.36512921750546]
    ]);
  });

  // test.only('super tangle shape', () => {
  //   expect(
  //     polyHelper.flattenPolygon(testData.selfCrossing.superCrossed)
  //   ).toEqual();
  // });
});

describe('f() untwistPolygon', () => {
  test('figure 8 shape', () => {
    expect(polyHelper.untwistPolygon2(testData.selfCrossing.figure8)).toEqual([
      [47.62547077805564, -122.35890716314317],
      [47.62451244150106, -122.35641773790121],
      [47.62358052652604, -122.35388807952404],
      [47.622408308237894, -122.35200570547505],
      [47.623046543509034, -122.35060773789881],
      [47.62461842205012, -122.34732739627363],
      [47.62493839613551, -122.3457458987832],
      [47.622514362878974, -122.3455883190036],
      [47.61998400149665, -122.34542939811946],
      [47.61841198360306, -122.3455883190036],
      [47.622408308237894, -122.35200570547505],
      [47.62198195084879, -122.35293958336115],
      [47.62041021901962, -122.35594365745784],
      [47.6190239823868, -122.35906608402729],
      [47.621262417655934, -122.35890716314317],
      [47.623792717162736, -122.35922399908304],
      [47.62493839613551, -122.35922399908304]
    ]);
  });

  test('simple star shape', () => {
    expect(
      polyHelper.untwistPolygon2(testData.selfCrossing.simpleStar)
    ).toEqual([
      [47.636951372875835, -122.3601721599698],
      [47.634805660998346, -122.36047957077123],
      [47.634527670811245, -122.35811792314054],
      [47.634123558657556, -122.36057729387629],
      [47.631704621063484, -122.36092384904624],
      [47.633622036769616, -122.36362948679673],
      [47.63295609026599, -122.3676823452115],
      [47.634473196097055, -122.36483054549288],
      [47.63548604966279, -122.36625976860522],
      [47.63516478853261, -122.36353051548]
    ]);
  });

  test('star shape', () => {
    expect(polyHelper.untwistPolygon2(testData.selfCrossing.star)).toEqual([
      [47.625044601790215, -122.34309755265713],
      [47.62283434984354, -122.3435716331005],
      [47.620516207885395, -122.34404738992453],
      [47.61886704233114, -122.34413224184358],
      [47.618305764473085, -122.34167497605087],
      [47.61681347588452, -122.33701128512621],
      [47.615987421710436, -122.33839463442564],
      [47.614301470947645, -122.34504403260058],
      [47.61207032343402, -122.34542939811946],
      [47.60796712466814, -122.3466943949461],
      [47.60964569351914, -122.34997574239968],
      [47.61175027058802, -122.35452108085154],
      [47.612675166690295, -122.35628691507925],
      [47.61196431744703, -122.36044976860283],
      [47.61081835414786, -122.36515268683432],
      [47.61396257325794, -122.36452069133519],
      [47.6165233889241, -122.36122913881263],
      [47.61798574978985, -122.36250400543213],
      [47.61934399071542, -122.363452501595],
      [47.620196206731656, -122.36467827111484],
      [47.621344902334194, -122.36512921750546],
      [47.62091869243119, -122.36121587455274],
      [47.62081112246857, -122.3563540354371],
      [47.62026373185413, -122.35257311820394],
      [47.62315433484945, -122.34732739627363]
    ]);
  });

  // test.only('super crossed tangled shape', () => {
  //   expect(
  //     polyHelper.untwistPolygon2()
  //   ).toEqual();
  // });
});

describe('f() directionOfPoint', () => {
  test('point is to the left', () => {
    expect(polyHelper.directionOfPoint([1, 1], [3, 3], [4, 5])).toEqual(-1);
  });
  test('point is to the right', () => {
    expect(polyHelper.directionOfPoint([1, 1], [3, 3], [2, 1])).toEqual(1);
  });
  test('point is to the left', () => {
    expect(polyHelper.directionOfPoint([1, 1], [3, 3], [4, 4])).toEqual(0);
  });
});

describe('f() lineIntersectPoint', () => {
  test('returns intersect point', () => {
    const pointA = [47.63021248898915, -122.35562715679409];
    const pointB = [47.625044601790215, -122.3520303145051];
    const pointC = [47.62957418507829, -122.34965924173594];
    const pointD = [47.626936382105306, -122.35732700675727];
    expect(
      polyHelper.lineIntersectPoint(pointA, pointB, pointC, pointD)
    ).toEqual([47.62804106009122, -122.35411584530702]);
  });

  test('returns shared point ', () => {
    const pointA = [47.63021248898915, -122.35562715679409];
    const pointB = [47.62957418507829, -122.34965924173594];
    const pointC = [47.62957418507829, -122.34965924173594];
    const pointD = [47.626936382105306, -122.35732700675727];
    expect(
      polyHelper.lineIntersectPoint(pointA, pointB, pointC, pointD)
    ).toEqual([47.62957418507829, -122.34965924173594]);
  });

  test('returns false if lines do not intersect intersect', () => {
    const pointA = [47.63021248898915, -122.35562715679409];
    const pointB = [47.62957418607829, -122.34965924183594];
    const pointC = [47.62957418507829, -122.34965924173594];
    const pointD = [47.626936382105306, -122.35732700675727];
    expect(
      polyHelper.lineIntersectPoint(pointA, pointB, pointC, pointD)
    ).toEqual(false);
  });
});

describe('f() merge', () => {
  test('basic cross shape', () => {
    expect(
      polyHelper.merge(testData.cross.vertical, testData.cross.horizontal)
    ).toEqual(testData.cross.merged);
  });

  test('figure 8', () => {
    expect(
      polyHelper.merge(
        testData.selfCrossing.figure8,
        testData.selfCrossing.figure8
      )
    ).toEqual(testData.selfCrossing.merge);
  });

  test('donut shape', () => {
    expect(polyHelper.merge(testData.donut.bottom, testData.donut.top)).toEqual(
      testData.donut.merged
    );
  });

  test('snake & spike shape', () => {
    expect(
      polyHelper.merge(testData.snake.snake, testData.snake.spike)
    ).toEqual(testData.snake.merged);
  });

  test('internal island shape', () => {
    expect(
      polyHelper.merge(testData.island.outer, testData.island.inner)
    ).toEqual(testData.island.merge);
  });

  test('with inverted shape', () => {
    expect(
      polyHelper.merge(testData.donut.top, testData.inverted.inverted)
    ).toEqual([
      [47.630634424342716, -122.34486428000214],
      [47.63042623432632, -122.34262347221373],
      [47.624192464808324, -122.34246589243413],
      [47.625044601790215, -122.35123939812182],
      [47.63049553022523, -122.35270114283274],
      [47.63042623432632, -122.35811792314054],
      [47.62653688140613, -122.35780142247677],
      [47.62704258370051, -122.36092384904624],
      [47.632636165262085, -122.36139826476573],
      [47.632636165262085, -122.34511423856019]
    ]);
  });
});

// test('difference funciton is working', () => {
//   const poly1 = [
//     [47.615987421710436, -122.35187273472549],
//     [47.619877785560334, -122.35499516129494],
//     [47.62008999122647, -122.34373055398466],
//     [47.61670725350713, -122.34495531767607]
//   ];
//   const poly2 = [
//     [47.62294055977313, -122.35076531767845],
//     [47.62853458032193, -122.34092462807892],
//     [47.62083620708049, -122.33744647353888],
//     [47.61841198360306, -122.3413584753871]
//   ];
//   const poly3 = [
//     [
//       [47.62083620708049, -122.33744647353888],
//       [47.61841198360306, -122.3413584753871],
//       [47.61963350025978, -122.34389583240937],
//       [47.62008999122647, -122.34373055398466],
//       [47.62006980455917, -122.3448021317806],
//       [47.62294055977313, -122.35076531767845],
//       [47.62853458032193, -122.34092462807892]
//     ]
//   ];
//   expect(polyHelper.difference(poly2, poly1)).toBe(poly3);
// });
